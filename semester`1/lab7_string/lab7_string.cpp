/* ЛАБОРАТОРНАЯ 7. СТРОКИ И ФАЙЛЫ
строки старого С-типа представляют из себя всего лишь массив
символов с нулевым окончанием:
char cstr1[] = "C-style string1";
char cstr2[] = { 'C', '-', 's', 't', 'y', 'l', 'e', ' ', 's', 't', 'r', 'i', 'n', 'g', '1', '\0' };
char cstr3[] = {'\67', '\0'};
std::string cppstr1 = "C++ - style string 1";
std::string cppstr2 = "";

 в типе char на самом деле хранится знаковое целое число. Можно
 складывать делить умножать char
 Чтобы придать смысл данным, хранимым в char, нужна таблица
 соответствия чисел с символами - кодовая таблица (ASCII, ANSI, UNICODE)
 ФУНКЦИИ ДЛЯ РАБОТЫ С С-СТРОКАМИ
 вывод на печать printf(char[], , ,) или printf(* char, ...) -
 print formatted
 с помощью printf можно не просто печатать готовую строку, но и
 подставлять в неё другие переменные, попутно преобразовывая их
 в символьный вид и применяя форматирование
 форматирование printf("базовая %s строка %f, параметр1, параметр2)
 позиции, куда будут подставляться параметры, обозначаетются в
 базовой строке символом %
 значение символов форматирования берётся из таблицы справки к
 функции http://www.cplusplus.com/reference/cstdio/printf/
 значения некоторых из них:
 %f - параметр подставляется на место %f, оформленное в виде числа с
 плавающей точкой
 %s - параметр подставляется на место %s, как строка
 %d - параметр подставляется на место %d, как целое число
 %e - параметр подставляется на место %e как число в
 экспоненциальном виде
 объединение (конкатенация) строк strcat(char*, char*)
 копирование из одной строки в другую strcpy()
 сравнение strcmp()
 длина строки strlen()
 вставка строки в подстроку производится в несколько действий

 в стандартной библиотеке C++ массив символови инкапсулирован в
 класс std::string
 в который так же собраны самые часто используемые методы обработки
 и для которого перегружены операторы + (конкатенация), ввод, вывод, ==,
 = и т.д.
 ещё одно отличие от строк С - длина строки теперь задаётся определенным
 числом, а не нклевым окончанием
 Цикл работы с файлом заключается в
 0.1 Проверить существует ли файл (в случае если нужно)
 0.2 При работу в C++ создать объект для работы с файлом
 1.Открытие файла
 2.Работа с файлом (чтение, запись, поиск)
 3.Закрытие файла
 */
 /*возникает соблазн передать массив в функцию следующим образом:
 void foo(int a[3]) {...}
 такой код будет компилироваться, работает он не совсем так, как ожидается.
int a[1] = {};
foo(a);
ожидается что в функцию можно будет передавать только массивы из трёх элементов,
этот код успешно скомпилируется.Компилятор не увидит никаких проблем, 
так как размерность массива в определении функции проигнорируется.
 
 В стандартной библиотеке есть следующие функции для строк. 
 strlen - 
 strcat - 
 strstr - 
 */

#include "pch.h"
#include <iostream>
#include <cstring> // библиотека для работы с Си строками
#include <string>
#include <fstream>
using namespace std;


	int main()
	{
		fstream fs;
		fstream text;
		text.open("Text.txt", fstream::in);
		fs.open("Some text.txt", fstream::out);

		string user_str;
		getline(text, user_str);
		string user_str2;
		getline(text, user_str2);

		cout << "input" << endl;
		cout << user_str << endl;

		cout << "input" << endl;
		cout << user_str2 << endl;


		int pos = 0;
		while (pos != string::npos) {
			pos = user_str.find(user_str2, pos);
			if (pos == string::npos) {
				break;
			}
			fs << pos + 1 << '\t';

			pos++;
		}
		text.close();
		fs.close();
	}

/*
ПОИСК величины массива чаров.
int n = 0;
  int i = 0;
  while (str[i] != '\0') {
	i++;
	n++;
  }
*/
/*

в с++ они бывают двух типов.
рассмотрим вариант первый
строки типа c-style. по факту тупа массив чаров. объявляется методом char a [] = “”;
когда инициализируешь строку сразу - писать ее размер не надо.
итого в нашей строке, которая является нашими мыслями о текущей ситуации, хранится 23+1символа. почему 23+1? потому что 23 фразы занимает правда жизни, а 1 символ отводится по \0.
\0  - окончание строки. именно по этому символу он понимает что строка заканчивается.
минутка подводных камней. далее пойдет речь о функциях которые возвращают например длину строки. так вот возвращают они значение именно строки без зигующего нуля. то есть, если ты создаешь динамический массив чтобы переложить туда значение нашей строчки, и хочешь узнать сколько же нужно выделить памяти, про не забывай про \0. если выделишь память только под текст, он так то перегонит все, но \0 запишется хуй знает куда. все будет работать штатно ДО МОМЕНТА УДАЛЕНИЯ. когда ты попытаешься удалить динамический массив, то он будет жутко ругаться мало понятными ошибками, ну или просто скажет что ты еблан и выходишь за пределы памяти.
Это - самые нужные функции для работы со строками си стайл.
Некоторые функции для  String.
Название функции
Описание
size_t strlen(const char *str)
Вычисляет длину строки, не считая завершающий символ (символ null)
char *strcpy(char *dest, const char *src)
Копирует строку 'src' в 'dest'.
int strcmp(const char *str1, const char *str2)
Сравнивает 2 строки данные параметром указателя str1, и  str2. Возвращает целое число > 0 то есть str1 > str2. И = 0 это 2 одинаковые строки, наоборот str1 < str2.
char *strcat(char *dest, const char *src)
Добавляет строку, на которую указывает src к концу строки на которую указывает dest.
char *strchr(const char *str, int c)
Ищет первое происхождение символа c (an unsigned char) в строке на которую указывает аргумент str.
 очень часто компилятор может начать ругаться на aeyrwb. strcpy, потому что она древняя как говно мамонта и считается не безопасной. мы можем:
поступить как умный человек, прислушаться к компилятору и решить проблему по другому
поступить как я. сказать компилятору “ты охуел” и впихнуть фразу CRT_SECURE_NO_WARNINGS в свойствах проекта -> c++ -> предпроцессор -> определения предпроцессора
можете еще впихнуть #define _CRT_SECURE_NO_WARNINGS
но там уже хз, у меня так не заработало.

Строки с++ - стайл
Это штука намного удобнее чем с-строки. потому что тут уже не надо так следить за размерами массивов, выделять память и т.д. по факту - те же яйца только в профиль.
объявляется как
 string s1 = “мой код кривее чем дороги в россии”;
тут вообще не надо думать над тем, какого все это размера. с++-стайл дает красивую обертку для работы со строками НО.
к элементу строки все равно можно обратиться через скобки
например как s1[4].
Ниже это список методов String.
- length()
length() это один из самых распространенных методов String, он возвращает длину строки (Число знаков строки). и да, возвращает он все это опять без \0. так что если занимаетесь перегонкой строк в динамические массивы - не забывайте про этого скрытого нулевого фашиста, иначе он испортит вам всю лабу/экзамен в тот момент, когда все отлажено, вроде даже работает и ты решил освободить память…
2. append
Эта функция склеивает строки. просто берет и склеивает. выглядит в коде как то так.
  // Append s2 into s1.
	  string s = s1.append(s2);
3- find
представьте себе, все задание, которое мы реализовывали в предварительном экзамене это по факту написать с нуля функции этих классов. нет, прикиньте - мы изобретали велосипед).
find - метод поиска позиции подстроки в текущей строке. Этот метод возвращает константу string::npos, если ничего не найдено.
int main() {

	string str = "This is text";
	//Найти индекс в этой строке первого появления 'i'.
	// ==> 2
	string::size_type idx = str.find('i');
	cout << "- find('i') = " << idx << endl;

	// Найти индекс в этой строке первого появления 'i'.
	// начало поиска с позиции 4
	 idx = str.find('i', 4);
	cout << "- find('i',4) = " << idx << endl;
}
4- substr
по факту - как ножницы. выводит тебе лишь определенный указанный отрезок.
при сочетании с методом поиска, как мне кажется, можно найти значение двух элементов и вывести все между ними
int main() {

	string str = "This is text";

	// Возвращает кусман строки от индекса т3 до конца строки.
 строка substr = str.substr(3);

	cout << "- str.substr(3)=" << substr << endl;

	// та же фигня от индекса 2 до индекса 7.
	substr = str.substr(2, 7);
	cout << "- str.substr(2, 7) =" << substr << endl;
}
6.insert
вставляет в строку нужный нам текст. выглядит так.
string str = "This text";

	string s2 = str.insert(5, "is ");

на выходе получаем что s2 - “This is text”
7.  upper/lower
 прикольная штука которая буквально заставляет строки орать на вас. то есть это конвертация 
 строки в строку с заглавными или в строку со строчными буквами.
делается это чуть более хитро.
Используем функцию  transform пространства (namespace) с названием  std:
   std::transform(str.begin(), str.end(),str.begin(), ::toupper);
или же
 std::transform(str.begin(), str.end(),str.begin(), ::tolower);
работает походу только с включенным неймспейсом.
вряд ли вы будете использовать эту функцию, но почему бы и не знать о ней. вдруг вам захочется написать программу, 
включение клавишу капс на клавиатуре.

	
*/
