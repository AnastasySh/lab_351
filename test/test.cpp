

#include "pch.h"
#include <iostream>
#include <cstring>
#include <string>
#include "classstr.h"

int main()
{
	setlocale(LC_ALL, "Russian");
	char a[] = { "12345" };
	std::string s1 = { "i`mtired" };
	str A1;
	A1.test();	
	str A2(a);
	A2.test();	
	/*str A3(s1);
	A3.test();
	str A4(A3);
	A4.test();
	A3.clear();//дальше проблемы
	A3.test();
	A1.add(s1);
	A1.test();
	A1.add(a);
	A1.test();*/
	A1.insert(s1);
	A1.test();
	A1 = A1 + s1;
	std::cout << A1;
	A2 = A2 + a;
	std::cout << A1;
	A1 = A1 + A2;
	std::cout << A1;
	A1.~str();
	A2.~str();
	/*A3.~str();
	A4.~str();*/

}
/*
Открытие файлов

Наиболее часто применяются классы ifstream для чтения,
ofstream для записи и fstream для модификации файлов.
Все поточные классы ввода-вывода являются косвенными
производными от общего предка ios, полностью наследуя его функциональность. 
Ниже приведены возможные значения флагов и их назначение.

Режим	Назначение
in	Открыть для ввода (выбирается по умолчанию для ifstream)
out	Открыть для вывода (выбирается по умолчанию для ofstream)
binary	Открыть файл в бинарном виде
aрр	Присоединять данные; запись в конец файла
ate	Установить файловый указатель на конец файла
trunc	Уничтожить содержимое, если файл существует (выбирается по умолчанию, если флаг out указан, а флаги ate и арр — нет)
Например, чтобы открыть файл с именем test.txt для чтения данных в бинарном виде, следует написать:

ifstream file;
file.open("test.txt", std::fstream::in | std::fstream::binary);

Оператор логического ИЛИ (|) позволяет составить режим с любым сочетанием флагов. Так, чтобы, открывая файл по записи, 
случайно не затереть существующий файл с тем же именем, надо использовать следующую форму:
ofstream file;
file.open ("test.txt", fstream::out | fstream::app);
Для проверки того удалось ли открыть файл, можно применять конструкцию

if (!file) {
 //Обработка ошибки открытия файла
}
Переопределённый в классах работы с файлами оператор включения (<<) записывает данные в файловый поток.
Как только вы открыли файл для записи, можно записывать в него текстовую строку целиком:

file << "Это строка текста";
Можно также записывать текстовую строку по частям:

file << "Это " << "строка " << "текста";
Оператор endl завершает ввод строки символом "возврат каретки":

file << "Это строка текста" << endl;
С помощью оператора включения несложно записывать в файл значения переменных или элементов массива.

Класс ifstream: чтение файлов

Как следует из расшифровки названия, класс ifstream предназначен для ввода файлового потока.
Далее перечислены основные методы класса. Большая часть из них унаследована от класса istream
и перегружена с расширением родительской функциональности. К примеру, функция get, в зависимости 
от параметра вызова, способна считывать не только одиночный символ, но и символьный блок.

Метод	Описание
open	Открывает файл для чтения
get	Читает один или более символов из файла
getline	Читает символьную строку из текстового файла или данные из бинарного файла до определенного ограничителя
read	Считывает заданное число байт из файла в память
eof	Возвращает ненулевое значение (true), когда указатель потока достигает конца файла
peek	Выдает очередной символ потока, но не выбирает его
seekg	Перемещает указатель позиционирования файла в заданное положение
tellg	Возвращает текущее значение указателя позиционирования файла
close	Закрывает файл

Следующий пример показывает добавление данных в текстовый файл с последующим чтением всего файла.
#include <iostream>
#include <fstream>
using namespace std;

int main() {
 ofstream file;
 file.open("test.txt",ios::out|ios::app);
 if (!file) {
  cout << "File error - can't open to write data!";
  cin.sync(); cin.get(); return 1;
 }
 for (int i=0; i<10; i++) file << i << endl;
 file.close();

 ifstream file2;
 file2.open("test.txt", ios::in);
 if (!file2) {
  cout << "File error - can't open to read data!";
  cin.sync(); cin.get(); return 2;
 }
 int a,k=0;
 while (1) {
  file2 >> a;
  if (file2.eof()) break;
  cout << a << " ";
  k++;
 }
 cout << endl << "K=" << k << endl;
 file2.close();

 cin.sync(); cin.get(); return 0;
}

Класс ofstream: запись файлов

Класс ofstream предназначен для вывода данных из файлового потока. Далее перечислены основные методы данного класса.

Метод	Описание
open	Открывает файл для записи
put	Записывает одиночный символ в файл
write	Записывает заданное число байт из памяти в файл
seekp	Перемещает указатель позиционирования в указанное положение
tellp	Возвращает текущее значение указателя позиционирования файла
close	Закрывает файл
Описанный ранее оператор включения удобен для организации записи в текстовый файл:

ofstream file ("temp.txt");
if (!file) return;
for (int i=1;  i<=3; i++)
file << "Строка " << i << endl;
file.close();
Бинарные файлы

В принципе, бинарные данные обслуживаются наподобие текстовых. 
Отличие состоит в том, что если бинарные данные записываются 
в определенной логической структуре, то они должны считываться 
из файла в переменную того же структурного типа.

Первый параметр методов write и read (адрес блока записи/чтения) 
должен иметь тип символьного указателя char *, поэтому необходимо 
произвести явное преобразование типа адреса структуры void *.
Второй параметр указывает, что бинарные блоки файла имеют постоянный
размер байтов независимо от фактической длины записи.
Следующее приложение дает пример создания и отображения данных 
простейшей записной книжки. Затем записи файла 
последовательно считываются и отображаются на консоли.

Класс fstream: произвольный доступ к файлу

Предположим что в нашей записной книжке накопилось 100 записей, 
а мы хотим считать 50-ю. Конечно, можно организовать цикл и
прочитать все записи с первой по заданную. Очевидно, что более
целенаправленное решение - установить указатель позиционирования
файла pos прямо на запись 50 и считать ее:
ifstream ifile("Notebook.dat", ios::binary);
int pos = 49 * sizeof(Notes);
ifile.seekg(pos); // поиск 50-й записи
Notes Note;
  //Notes – описанная выше структура "запись"
ifile.read((char*)&Note, sizeof(Notes));

Подобные операции поиска эффективны, если файл состоит
из записей известного и постоянного размера. Чтобы заменить 
содержимое произвольной записи, надо открыть поток вывода в режиме модификации:

ofstream ofilе ("Notebook.dat",
		 ios::binary | ios::ate);
int pos = 49 * sizeof(Notes);
ofile seekp(pos); // поиск 50-й записи
Notes Note50 =
 {"Ельцин Борис Николаевич", "095-222-3322", 64};
ofile.write((char*)&Note, sizeof(Notes)); // замена

Если не указать флаг ios::ate (или ios::app), то при открытии бинарного файла Notebook.dat его предыдущее содержимое будет стерто!

// Открыть файл на чтение/запись одновременно
 fstream file("Notebook.dat", ios::binary | ios::in | ios::out);
*/